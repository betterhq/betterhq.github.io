<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java并发编程：Lock | 来一杯82年的Java</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发编程：Lock</h1><a id="logo" href="/.">来一杯82年的Java</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/historys/"><i class="fa fa-book"> 历史</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/rss/"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java并发编程：Lock</h1><div class="post-meta">Aug 28, 2018</div><div class="post-content"><h3 id="一、synchronized与Lock的比较"><a href="#一、synchronized与Lock的比较" class="headerlink" title="一、synchronized与Lock的比较"></a>一、synchronized与Lock的比较</h3><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p>
<p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p>
<ul>
<li>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有</li>
<li>2）线程执行发生异常，此时JVM会让线程自动释放锁。</li>
</ul>
<p>　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p>
<p>　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p>
<p>　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p>
<p>　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p>
<p>　　因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p>　　另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p>
<p>　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p>
<ul>
<li>1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问;</li>
<li>2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
</ul>
<h3 id="二、java-util-concurrent-locks包下常用的类"><a href="#二、java-util-concurrent-locks包下常用的类" class="headerlink" title="二、java.util.concurrent.locks包下常用的类"></a>二、java.util.concurrent.locks包下常用的类</h3><h4 id="1、-Lock"><a href="#1、-Lock" class="headerlink" title="1、 Lock"></a>1、 Lock</h4><p>Lock是一个接口，源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line"></span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    boolean tryLock();</span><br><span class="line"></span><br><span class="line">    boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    void unlock();</span><br><span class="line"></span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中unLock()方法是用来释放锁的。newCondition()这个方法暂且不做讲述。</p>
<p>Lock接口提供了四种获取锁的方法：</p>
<ul>
<li>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</li>
<li>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li>
<li>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li>
<li>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li>
</ul>
<h4 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h4><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在《几种锁的概念》一文中讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock</p>
<p>例1、lock()的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class LockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        lockInsertTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void lockInsertTest()&#123;</span><br><span class="line">        final LockDemo lockDemo = new LockDemo();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    lockDemo.lockInsert(Thread.currentThread());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void lockInsert(Thread thread)&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-0释放了锁</span><br><span class="line">Thread-1得到了锁</span><br><span class="line">Thread-1释放了锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>例2、tryLock()的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class LockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        tryLockInsertTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void tryLockInsertTest()&#123;</span><br><span class="line">        final LockDemo lockDemo = new LockDemo();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    lockDemo.tryLockInsert(Thread.currentThread());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void tryLockInsert(Thread thread)&#123;</span><br><span class="line">        if (lock.tryLock())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">                for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(thread.getName() + &quot;得到锁失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1得到锁失败</span><br><span class="line">Thread-0释放了锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>例3、lockInterruptibly()响应中断的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class LockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        lockInterruptiblyInsertTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void lockInterruptiblyInsertTest()&#123;</span><br><span class="line">        final LockDemo lockDemo = new LockDemo();</span><br><span class="line"></span><br><span class="line">        MyThread thread0 = new MyThread(lockDemo);</span><br><span class="line">        MyThread thread1 = new MyThread(lockDemo);</span><br><span class="line"></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread1.interrupt();//中断处于等待状态的thread2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptiblyInsert(Thread thread) throws InterruptedException &#123;</span><br><span class="line">        lock.lockInterruptibly();//可以响应中断，如果用lock()则会继续等待</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName() + &quot;得到了锁&quot;);</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private LockDemo lockDemo;</span><br><span class="line"></span><br><span class="line">    public MyThread(LockDemo lockDemo) &#123;</span><br><span class="line">        this.lockDemo = lockDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lockDemo.lockInterruptiblyInsert(Thread.currentThread());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1被中断</span><br><span class="line">Thread-0释放了锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<h4 id="3、-ReadWriteLock"><a href="#3、-ReadWriteLock" class="headerlink" title="3、 ReadWriteLock"></a>3、 ReadWriteLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadWriteLock也是一个接口，在它里面只定义了两个方法，<br>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p>
<h4 id="4、-ReentrantReadWriteLock"><a href="#4、-ReentrantReadWriteLock" class="headerlink" title="4、 ReentrantReadWriteLock"></a>4、 ReentrantReadWriteLock</h4><p>ReentrantReadWriteLock类中含有两个锁：ReadLock（读锁），WriteLock（写锁），这两个锁都是Lock接口的实现。</p>
<ul>
<li>读锁允许多个线程同时占用。</li>
<li>如果有一个线程已经占用了读锁，此时其他线程如果要申请写锁，申请写锁的线程会一直等待读锁的释放。</li>
<li>如果有一个线程已经占用了写锁，此时其他线程如果申请写锁或者读锁，申请的线程会一直等待写锁的释放。</li>
</ul>
<p>读写锁使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class LockDemo &#123;</span><br><span class="line"></span><br><span class="line">    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        readWriteLockTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void readWriteLockTest()&#123;</span><br><span class="line">        final LockDemo lockDemo = new LockDemo();</span><br><span class="line">        //两个读线程</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    lockDemo.readLockAction(Thread.currentThread());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //一个写线程</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lockDemo.writeLockAction(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readLockAction(Thread thread)&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">            System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeLockAction(Thread thread)&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行写操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;写操作完毕&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">            System.out.println(thread.getName() + &quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1读操作完毕</span><br><span class="line">Thread-0释放了锁</span><br><span class="line">Thread-1释放了锁</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2正在进行写操作</span><br><span class="line">Thread-2写操作完毕</span><br><span class="line">Thread-2释放了锁</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>可以看到，两个读线程可以同时进行读操作，写线程必须等到读线程释放“读锁”，才能获取到写锁，进行写操作</p>
<h4 id="4、-Lock和synchronized的选择"><a href="#4、-Lock和synchronized的选择" class="headerlink" title="4、 Lock和synchronized的选择"></a>4、 Lock和synchronized的选择</h4><p>总结来说，Lock和synchronized有以下几点不同：</p>
<ul>
<li>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>5）Lock可以提高多个线程进行读操作的效率。</li>
</ul>
<p>　　从性能上来说，在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock（差不多是两倍），但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态<br>　　<br><br><br><br>参考文章：<br> <a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/28/JDK自带线程池/">JDK自带线程池</a><a class="next" href="/2018/08/28/几种锁的概念/">几种锁的概念</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/CAS算法拙见/">CAS算法拙见</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：ThreadLocal/">Java并发编程：ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之synchronized与Object/">生产者消费者模型之synchronized与Object</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK发令枪CountDownLatch/">JDK发令枪CountDownLatch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK自带线程池/">JDK自带线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：Lock/">Java并发编程：Lock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/几种锁的概念/">几种锁的概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/记一次AOP-反射-自定义注解结合的应用/">记一次AOP,反射,自定义注解结合的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/1秒30000QPS-前后端设计思路/">1秒30000QPS,前后端设计思路</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="广告位1" target="_blank">广告位1</a><ul></ul><a href="http://www.example2.com/" title="广告位2" target="_blank">广告位2</a><ul></ul><a href="http://www.example3.com/" title="广告位3" target="_blank">广告位3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">来一杯82年的Java.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>