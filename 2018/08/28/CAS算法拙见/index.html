<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CAS算法拙见 | 来一杯82年的Java</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CAS算法拙见</h1><a id="logo" href="/.">来一杯82年的Java</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/historys/"><i class="fa fa-book"> 历史</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CAS算法拙见</h1><div class="post-meta">Aug 28, 2018</div><div class="post-content"><h3 id="一、前置知识点"><a href="#一、前置知识点" class="headerlink" title="一、前置知识点"></a>一、前置知识点</h3><h4 id="1、悲观锁与乐观锁："><a href="#1、悲观锁与乐观锁：" class="headerlink" title="1、悲观锁与乐观锁："></a>1、悲观锁与乐观锁：</h4><a id="more"></a>
<ul>
<li><p>悲观锁：<br><br>悲观锁总是很悲观，在事情还未发生前，会做最坏的假设，做一些用于保证安全的处理。<br><br>在多条线程对一个临界区资源进行操作时，悲观锁总是认为这些线程的操作会产生冲突，所以为了避免冲突，悲观锁会只让一条线程进入临界区，其他线程必须等待，宁愿牺牲性能，也要保证资源绝对安全。</p>
</li>
<li><p>乐观锁 <br><br>乐观锁总是很乐观，在事情发生之后，才会考虑事情的好与坏，最后再做处理。<br><br>在多条线程对一个临界区资源进行操作时，乐观锁总是认为这些线程的操作不会产生冲突，所以也不需要线程等待，线程们持续运行，在这些线程对临界区的操作结束之后，乐观锁会校验这些操作是否冲突（比如加version字段，预期值与操作后的值进行校验），如果冲突，再做相应处理（丢弃或重试）。</p>
</li>
</ul>
<h3 id="二、CAS算法简介"><a href="#二、CAS算法简介" class="headerlink" title="二、CAS算法简介"></a>二、CAS算法简介</h3><p>我们平时在做并发控制的时候，使用最多的应该是<code>synchronized</code>关键字和<code>Lock</code>锁，这是一种悲观锁的处理方式，虽然很安全，但是会损失性能。</p>
<p>CAS算法（Compare and Swap 比较交换）是一种乐观锁的实现策略</p>
<p>CAS操作是这样子一个过程：<br>一共有3个操作数，内存中的值<code>V</code>，预期值<code>A</code>，操作后的新值<code>B</code>，当且仅当 <code>V==A</code> 时，<code>V</code>才会被更新成<code>B</code>。</p>
<p><strong>例</strong>：现在有<code>线程1</code>和<code>线程2</code>同时对临界区的一个数据 <code>X</code> 进行操作，主存中<code>X</code>的值是100，<code>线程1</code>和<code>线程2</code>同时读取主存中<code>X</code>的值到自己的工作内存，这时<code>线程1</code>和<code>线程2</code>的预期值都是100，<code>线程1</code>先对<code>X</code>进行<code>+1</code>操作，校验主存值和预期值通过，把<code>X</code>的值更新成101，<code>线程2</code>后对<code>X</code>进行<code>+1</code>操作，写入主存之前校验主存中<code>X</code>的值和预期值，发现主存中<code>X</code>=101和预期值100不等，更新失败，之后重试。</p>
<p><strong>通俗解释</strong>：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值，类似于数据库的commit-retry模式，在并发冲突较少的时候，这样子可以带来较大的性能提升。</p>
<h3 id="三、借用jdk1-8中J-U-C的AtomicInteger类加深理解"><a href="#三、借用jdk1-8中J-U-C的AtomicInteger类加深理解" class="headerlink" title="三、借用jdk1.8中J.U.C的AtomicInteger类加深理解"></a>三、借用jdk1.8中J.U.C的AtomicInteger类加深理解</h3><p><code>java.util.concurrent.atomic</code>包下实现了实现了一些直接使用CAS操作的线程安全的类，用<code>AtomicInteger</code>类来看一下 Doug Lea大神 怎么实现无锁情况下的线程安全。</p>
<p><code>AtomicInteger</code>类中的所有属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe类是一个JDK内部使用的专属类，封装了一些类似指针的操作，因为指针的操作是不安全的。</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">//指value值相对于AtomicInteger对象首地址的在内存中偏移量，根据这个地址可以准确的定位value的值。</span><br><span class="line">private static final long valueOffset;</span><br><span class="line">//计算偏移量</span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line">//是当前实际的值，使用`volatile`修饰实现线程间的可见性。</span><br><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure></p>
<p>观察<code>AtomicInteger</code>类中的+1操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//jdk1.8对CAS操作进行了增强，参考 http://ifeve.com/enhanced-cas-in-jdk8/</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接来看<code>Unsafe</code>类的<code>getAndAddInt()</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取并增加</span><br><span class="line"> * getIntVolatile()方法，compareAndSwapInt()方法，为native方法，没有做深入的研究</span><br><span class="line"> * @param var1 指定对象</span><br><span class="line"> * @param var2 偏移量</span><br><span class="line"> * @param var4 增加的数值</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        //拿到指定对象的首地址，通过偏移量得到对应属性（这里实际上就是value）。</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    //死循环（自旋），CAS操作，如果失败，继续重试，直至成功。</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    //返回最终内存中的值</span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个<code>J.U.C</code>都是建立在CAS之上的，<code>java.util.concurrent.atomic</code>包下的类都是利用JNI来完成CPU的CAS指令操作，完成非阻塞算法，其它原子操作都是利用类似的特性完成的。</p>
<h3 id="四、CAS操作的缺点"><a href="#四、CAS操作的缺点" class="headerlink" title="四、CAS操作的缺点"></a>四、CAS操作的缺点</h3><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。</p>
<ul>
<li><p>1、ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<br><br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</li>
<li><p>2、循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li><p>3、只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ul>
<p><br><br><br>参考文章：<br><a href="http://www.cnblogs.com/dayhand/p/3713303.html" target="_blank" rel="noopener">http://www.cnblogs.com/dayhand/p/3713303.html</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2018/08/28/Java并发编程：ThreadLocal/">Java并发编程：ThreadLocal</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/CAS算法拙见/">CAS算法拙见</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：ThreadLocal/">Java并发编程：ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之synchronized与Object/">生产者消费者模型之synchronized与Object</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK发令枪CountDownLatch/">JDK发令枪CountDownLatch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK自带线程池/">JDK自带线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：Lock/">Java并发编程：Lock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/几种锁的概念/">几种锁的概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/记一次AOP-反射-自定义注解结合的应用/">记一次AOP,反射,自定义注解结合的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/1秒30000QPS-前后端设计思路/">1秒30000QPS,前后端设计思路</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="广告位1" target="_blank">广告位1</a><ul></ul><a href="http://www.example2.com/" title="广告位2" target="_blank">广告位2</a><ul></ul><a href="http://www.example3.com/" title="广告位3" target="_blank">广告位3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">来一杯82年的Java.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>