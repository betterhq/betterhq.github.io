<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java并发编程：ThreadLocal | 来一杯82年的Java</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发编程：ThreadLocal</h1><a id="logo" href="/.">来一杯82年的Java</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/historys/"><i class="fa fa-book"> 历史</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java并发编程：ThreadLocal</h1><div class="post-meta">Aug 28, 2018</div><div class="post-content"><h2 id="一、ThreadLocal简介："><a href="#一、ThreadLocal简介：" class="headerlink" title="一、ThreadLocal简介："></a>一、ThreadLocal简介：</h2><p><code>ThreadLocal</code>类提供了四个方法：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get()：返回此线程局部变量的当前线程副本中的值。</span><br><span class="line">initialValue()：返回此线程局部变量的当前线程的“初始值”，默认返回null，供子类重写。</span><br><span class="line">remove()：移除此线程局部变量当前线程的值。</span><br><span class="line">set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</span><br></pre></td></tr></table></figure></p>
<p><code>ThreadLocal</code>，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。</p>
<p><code>ThreadLocal</code>和线程同步机制不同，线程同步机制主要采用<code>synchronized</code>关键字和<code>J.U.C</code>中的<code>Lock</code>对象来实现，也就是加锁，加锁的目的是为了能让多个线程安全的共享一个变量。</p>
<p>而<code>ThreadLocal</code>为每个线程创建了自己独有的变量副本，也就是说，线程可以随意的操作自己拥有的变量副本，不会对其他线程的变量副本产生影响，实现了线程隔离。</p>
<h2 id="二、ThreadLocal实现原理："><a href="#二、ThreadLocal实现原理：" class="headerlink" title="二、ThreadLocal实现原理："></a>二、ThreadLocal实现原理：</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBee879c7eb828db594a1191ea067d4f58?method=download&amp;shareKey=79293e74afb7224f1fa8efb3a8ca32da" alt="ThreadLocal实现原理"></p>
<h3 id="1、怎么实现线程隔离"><a href="#1、怎么实现线程隔离" class="headerlink" title="1、怎么实现线程隔离"></a>1、怎么实现线程隔离</h3><p><code>ThreadLocal</code>类中的静态内部类<code>ThreadLocalMap</code>，这个<code>Map</code>是<code>ThreadLocal</code>实现线程隔离的精髓。</p>
<p><code>Thread</code>类中有这样子一个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 与此线程相关的ThreadLocalMap */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure></p>
<p>因此，一个线程对应有自己单独的一个<code>ThreadLocalMap</code>。</p>
<p>所以<code>ThreadLocal</code>才可以实现线程隔离（<code>Thread</code>，<code>ThreadLocal</code>，<code>ThreadLocalMap</code>三者的对应关系如图所示）</p>
<h3 id="2、对象存储和获取原理"><a href="#2、对象存储和获取原理" class="headerlink" title="2、对象存储和获取原理"></a>2、对象存储和获取原理</h3><p><code>ThreadLocal</code>的<code>set</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>ThreadLocal</code>的<code>set</code>方法看出，<code>ThreadLocalMap</code>的<code>&lt;k,v&gt;</code>结构中，<code>key</code>存储的是<code>ThreadLocal</code>本身，而<code>value</code>则是实际存储的值，也就是说，在<code>ThreadLocalMap</code>里存储了当前<code>ThreadLocal</code>所复制的变量副本。</p>
<p><code>ThreadLocal</code>本身不存储值，在使用中，<code>ThreadLocal</code>是作为一个<code>key</code>，从<code>ThreadLocalMap</code>获取值，从<code>ThreadLocal</code>的<code>get</code>方法中也可以看出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、ThreadLocal内存泄漏"><a href="#三、ThreadLocal内存泄漏" class="headerlink" title="三、ThreadLocal内存泄漏"></a>三、ThreadLocal内存泄漏</h2><h3 id="1、ThreadLocal内存泄漏问题概述"><a href="#1、ThreadLocal内存泄漏问题概述" class="headerlink" title="1、ThreadLocal内存泄漏问题概述"></a>1、ThreadLocal内存泄漏问题概述</h3><p><code>ThreadLocalMap</code>的静态内部类<code>Entry</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ThreadLocalMap</code>使用静态内部类<code>Entry</code>实现<code>&lt;k,v&gt;</code>存储，而<code>Entry</code>继承<code>WeakReference</code>类，所以<code>ThreadLocalMap</code>中的<code>key</code>其实是<code>ThreadLocal</code>的一个弱引用。</p>
<p>正因为<code>ThreadLocalMap</code>以<code>ThreadLocal</code>的弱引用作为<code>key</code>，在这个<code>ThreadLocal</code>没有外部强引用的时候，会被GC。这时候，<code>ThreadLocalMap</code>会出现一个<code>key</code>为<code>null</code>的<code>Entry</code>，理所当然的，这个<code>Entry</code>的<code>value</code>将永远没办法被访问到。</p>
<p>在这种情况下，如果当前工作线程一直没有结束，那这个<code>key</code>为<code>null</code>的<code>value</code>因为被<code>Entry</code>强引用，而<code>Entry</code>被当前线程的<code>ThreadLocalMap</code>强引用，导致这个<code>value</code>永远无法被GC，造成内存泄漏。</p>
<p>虽然在<code>ThreadLocalMap</code>的设计中，已经考虑到这种情况的发生：</p>
<ul>
<li><code>ThreadLocalMap</code>的<code>cleanSomeSlots()</code>，<code>expungeStaleEntry()</code>方法都能清除<code>key</code>为<code>null</code>的<code>value</code>。</li>
<li>在<code>ThreadLocal</code>的<code>set()</code>，<code>get()</code>，<code>remove()</code>方法中，都会调用<code>cleanSomeSlots()</code>或<code>expungeStaleEntry()</code>来清除<code>ThreadLocalMap</code>中所有<code>key</code>为<code>null</code>的<code>value</code>。</li>
</ul>
<p>但是这种被动清除的方式并不是在所有情况下都能保证不出现内存泄漏，反例：</p>
<ul>
<li>如果<code>ThreadLocal</code>的<code>set()</code>，<code>get()</code>，<code>remove()</code>方法没有被调用，就会导致<code>value</code>的内存泄漏。</li>
<li>用<code>static</code>修饰的<code>ThreadLocal</code>，导致<code>ThreadLocal</code>的生命周期和持有它的类一样长，意味着这个<code>ThreadLocal</code>不会被GC。这种情况下，如果不手动删除，<code>Entry</code>的<code>key</code>永远不为<code>null</code>，弱引用就失去了意义，理所当然的无法通过调用<code>cleanSomeSlots()</code>，<code>expungeStaleEntry()</code>方法清除<code>value</code>，如果当前线程结束了，就导致了<code>Entry</code>的内存泄漏。</li>
</ul>
<h3 id="2、ThreadLocalMap的key为什么使用弱引用"><a href="#2、ThreadLocalMap的key为什么使用弱引用" class="headerlink" title="2、ThreadLocalMap的key为什么使用弱引用"></a>2、ThreadLocalMap的key为什么使用弱引用</h3><p>看到这里可能会有这种感觉：内存泄漏都是因为<code>key</code>的弱引用造成的啊？那为什么不用强引用呢？</p>
<p>表面上看起来好像是这样子，那试想一下，如果<code>key</code>使用强引用，可以有这样子的对比：</p>
<ul>
<li><strong><code>key</code>使用强引用</strong>：在当前<code>ThreadLocal</code>没有外部强引用时，<code>ThreadLocalMap</code>的<code>Entry</code>还保持着<code>ThreadLocal</code>的强引用，<code>ThreadLocal</code>不会被GC。如果没有手动删除，并且当前线程结束了，就导致了<code>Entry</code>的内存泄漏。（有点类似用<code>static</code>修饰<code>ThreadLocal</code>的情况）</li>
<li><strong><code>key</code>使用弱引用</strong>：在当前<code>ThreadLocal</code>没有外部强引用时，<code>ThreadLocalMap</code>只保持着<code>ThreadLocal</code>的弱引用，无论有没有手动删除，<code>ThreadLocal</code>都会被GC，只要下一次<code>cleanSomeSlots()</code>，<code>expungeStaleEntry()</code>被调用，<code>value</code>就会被清除，否则也会引起内存泄漏。</li>
</ul>
<p>通过这样子的对比，我们可以得出：由于<code>ThreadLocalMap</code>的生命周期和<code>Thread</code>一样长，如果没有手动删除，都有可能会导致内存泄漏，但是弱引用多了一层保障：<strong>使用弱引用时，<code>ThreadLocal</code>无论如何都不会内存泄漏，只要下一次<code>cleanSomeSlots()</code>，<code>expungeStaleEntry()</code>被调用，<code>value</code>就会被清除。</strong></p>
<p>通过对比我们也可以看出：<code>ThreadLocal</code>引起的内存泄漏的根源，是因为<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，并且在线程结束之前，没有删除<code>key</code>，并不是因为弱引用。</p>
<h2 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h2><ul>
<li><strong><code>ThreadLocalMap</code>解决哈希冲突的方法</strong>：“开放定址法”。</li>
<li><strong>内存溢出 out of memory</strong> :指程序申请内存时，没有足够的内存供申请者使用，例如，有一块存储int类型数据的存储空间，但是程序员却用它存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM，即所谓的内存溢出。 </li>
<li><strong>内存泄漏memory leak</strong> :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</li>
</ul>
<p><br><br><br>参考文章：<br><a href="http://cmsblogs.com/?p=2442" target="_blank" rel="noopener">http://cmsblogs.com/?p=2442</a><br><a href="http://www.cnblogs.com/onlywujun/p/3524675.html" target="_blank" rel="noopener">http://www.cnblogs.com/onlywujun/p/3524675.html</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/28/CAS算法拙见/">CAS算法拙见</a><a class="next" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/CAS算法拙见/">CAS算法拙见</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：ThreadLocal/">Java并发编程：ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之synchronized与Object/">生产者消费者模型之synchronized与Object</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK发令枪CountDownLatch/">JDK发令枪CountDownLatch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK自带线程池/">JDK自带线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：Lock/">Java并发编程：Lock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/几种锁的概念/">几种锁的概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/记一次AOP-反射-自定义注解结合的应用/">记一次AOP,反射,自定义注解结合的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/1秒30000QPS-前后端设计思路/">1秒30000QPS,前后端设计思路</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="广告位1" target="_blank">广告位1</a><ul></ul><a href="http://www.example2.com/" title="广告位2" target="_blank">广告位2</a><ul></ul><a href="http://www.example3.com/" title="广告位3" target="_blank">广告位3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">来一杯82年的Java.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>