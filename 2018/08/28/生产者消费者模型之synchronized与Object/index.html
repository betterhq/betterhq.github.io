<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>生产者消费者模型之synchronized与Object | 来一杯82年的Java</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">生产者消费者模型之synchronized与Object</h1><a id="logo" href="/.">来一杯82年的Java</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/historys/"><i class="fa fa-book"> 历史</i></a><a href="/comments/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/rss/"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">生产者消费者模型之synchronized与Object</h1><div class="post-meta">Aug 28, 2018</div><div class="post-content"><h3 id="Object-wait-notify-notifyAll-的应用"><a href="#Object-wait-notify-notifyAll-的应用" class="headerlink" title="Object.wait(),notify()/notifyAll()的应用"></a>Object.wait(),notify()/notifyAll()的应用</h3><a id="more"></a>
<blockquote>
<p>Object.wait(),notify()/notifyAll()必须要与synchronized(obj)一起使用，也就是wait()与notify()/notifyAll()是针对已经获取了obj锁进行的操作。从语法的角度来说就是只能在同步方法或同步代码块中调用wait()和 notify()/notifyAll()方法。如果不是在同步方法或同步代码块中调用这些方法，程序能通过编译，但是运行的时候，将会得到IllegalMonitorStateException异常。从功能上来说就是wait()在获取对象锁之后，主动释放对象锁，同时本线程休眠，直到有其它线程调用对象的notify()/notifyAll()唤醒该线程才能继续获取对象锁，并继续执行。但是有一点需要注意的是notify()/notifyAll()调用之后并不是马上就释放对象锁，而是在相应的synchronized(obj){…}代码块执行结束后才释放的。</p>
</blockquote>
<h4 id="通过经典的生产者消费者模型理解："><a href="#通过经典的生产者消费者模型理解：" class="headerlink" title="通过经典的生产者消费者模型理解："></a>通过经典的生产者消费者模型理解：</h4><p>仓库类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class Storage &#123;</span><br><span class="line"></span><br><span class="line">    //仓库最大容量</span><br><span class="line">    private static final int MAX_SIZE = 100;</span><br><span class="line">    //仓库存储的载体</span><br><span class="line">    private LinkedList list = new LinkedList();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费产品</span><br><span class="line">     * @param num 数量</span><br><span class="line">     */</span><br><span class="line">    public void consume(int num) &#123;</span><br><span class="line">        synchronized (list)&#123;</span><br><span class="line">            while (num &gt; list.size())&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;【要消费的产品数量】：&quot; + num + &quot;【库存量】：&quot; + list.size() + &quot;【仓库库存不够，暂不能执行消费任务】&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                list.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;【已经消费产品数】:&quot; + num + &quot;【现库存量为】:&quot; + list.size());</span><br><span class="line"></span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生产产品</span><br><span class="line">     * @param num 数量</span><br><span class="line">     */</span><br><span class="line">    public void produce(int num) &#123;</span><br><span class="line">        synchronized (list)&#123;</span><br><span class="line">            while (list.size() + num &gt; MAX_SIZE)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;【要生产的产品数量】：&quot; + num + &quot;【库存量】：&quot; + list.size() + &quot;【仓库容量不够，暂不能执行生产任务】&quot;);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                list.add(new Object());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;【已经生产产品数】:&quot; + num + &quot;【现库存量为】:&quot; + list.size());</span><br><span class="line"></span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生产者类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num;</span><br><span class="line"></span><br><span class="line">    private Storage storage;</span><br><span class="line"></span><br><span class="line">    public Producer(Storage storage)&#123;</span><br><span class="line">        this.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Producer setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        storage.produce(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num;</span><br><span class="line"></span><br><span class="line">    private Storage storage;</span><br><span class="line"></span><br><span class="line">    public Consumer(Storage storage)&#123;</span><br><span class="line">        this.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Consumer setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        storage.consume(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Storage storage = new Storage();</span><br><span class="line">        LinkedList&lt;Producer&gt; producers = new LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Consumer&gt; consumers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            producers.add(new Producer(storage).setNum((i+1) * 10));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            consumers.add(new Consumer(storage).setNum((i+1) * 10));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ExecutorService producersService = Executors.newCachedThreadPool();</span><br><span class="line">        final ExecutorService consumersService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        consumers.forEach(c -&gt; consumersService.execute(c));</span><br><span class="line">        producers.forEach(p -&gt; producersService.execute(p));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pool-2-thread-1【要消费的产品数量】：10【库存量】：0【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-3【要消费的产品数量】：30【库存量】：0【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-5【要消费的产品数量】：50【库存量】：0【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-4【要消费的产品数量】：40【库存量】：0【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-2【要消费的产品数量】：20【库存量】：0【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-1-thread-1【已经生产产品数】:10【现库存量为】:10</span><br><span class="line">pool-1-thread-2【已经生产产品数】:20【现库存量为】:30</span><br><span class="line">pool-2-thread-2【已经消费产品数】:20【现库存量为】:10</span><br><span class="line">pool-2-thread-4【要消费的产品数量】：40【库存量】：10【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-5【要消费的产品数量】：50【库存量】：10【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-1-thread-5【已经生产产品数】:50【现库存量为】:60</span><br><span class="line">pool-2-thread-3【已经消费产品数】:30【现库存量为】:30</span><br><span class="line">pool-2-thread-1【已经消费产品数】:10【现库存量为】:20</span><br><span class="line">pool-2-thread-5【要消费的产品数量】：50【库存量】：20【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-2-thread-4【要消费的产品数量】：40【库存量】：20【仓库库存不够，暂不能执行消费任务】</span><br><span class="line">pool-1-thread-4【已经生产产品数】:40【现库存量为】:60</span><br><span class="line">pool-1-thread-3【已经生产产品数】:30【现库存量为】:90</span><br><span class="line">pool-2-thread-4【已经消费产品数】:40【现库存量为】:50</span><br><span class="line">pool-2-thread-5【已经消费产品数】:50【现库存量为】:0</span><br><span class="line">pool-1-thread-2【已经生产产品数】:60【现库存量为】:60</span><br><span class="line">pool-1-thread-4【要生产的产品数量】：80【库存量】：60【仓库容量不够，暂不能执行生产任务】</span><br><span class="line">pool-1-thread-5【要生产的产品数量】：90【库存量】：60【仓库容量不够，暂不能执行生产任务】</span><br><span class="line">pool-1-thread-1【要生产的产品数量】：100【库存量】：60【仓库容量不够，暂不能执行生产任务】</span><br><span class="line">pool-1-thread-3【要生产的产品数量】：70【库存量】：60【仓库容量不够，暂不能执行生产任务】</span><br></pre></td></tr></table></figure></p>
<h4 id="程序中几个关键点的解释："><a href="#程序中几个关键点的解释：" class="headerlink" title="程序中几个关键点的解释："></a>程序中几个关键点的解释：</h4><ul>
<li>仓库类consume()和produce()方法中的条件判断程序块，为什么不能用if：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (num &gt; list.size())&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">while (list.size() + num &gt; MAX_SIZE)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如果使用if，调用wait()方法后，当前线程阻塞，让出对象锁，其他线程获得对象锁，其他线程执行完让出对象锁后，调用notify()方法，此线程正好被唤醒，就不进行条件判断，继续执行后面的代码块了。因此为了让线程每次被唤醒都需要判断这个条件，使用while。</p>
</blockquote>
<ul>
<li>仓库类consume()和produce()方法执行到最后调用的是notifyAll()而不是notify()：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.notifyAll();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如果使用notify()，唤醒的是任意一个线程，没办法保证唤醒的是对方线程。<br><br>比如说，一个consumer线程A执行结束之后，库存量为0，这个线程调用notify()，只唤醒了另一个consumer线程B，这时候线程B会因为不满足条件而阻塞，而其他的线程都没有被唤醒，还是原来的阻塞状态，这时候整个程序就死锁了。<br><br>因此，consume()和produce()方法执行到最后必须调用notifyAll()方法，这样子就可以唤醒所有线程，由操作系统来觉得哪个线程先获得对象锁，并且先执行。<br></p>
</blockquote>
<p>这种方式实现的生产者消费者模型在性能上还可以优化：</p>
<p>在这种方式下，每个线程执行完，都会唤醒所有的线程，然后由操作系统来调度具体哪个线程先拿到对象锁，并执行。</p>
<p>但是在实际需求中，生产者生产完之后，只需要唤醒消费者来消费就可以了；同理，消费者消费完之后，只需要唤醒生产者来生产就可以了。</p>
<p>可以利用Lock与Condition的组合代替synchronized与Object的组合，实现这种效果。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>额外说两点：</p>
<ul>
<li><p>synchronized关键字标记在静态方法上是锁当前的class对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized static void XXXXX()&#123;</span><br><span class="line">	// 锁的对象是 当前的 class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized关键字标记在非静态方法上是锁当前的实例对象（this）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized  void XXXXX()&#123;</span><br><span class="line">	// 锁的对象是 当前的 this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br><br><br><br><br><br><br></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a><a class="next" href="/2018/08/28/JDK发令枪CountDownLatch/">JDK发令枪CountDownLatch</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/CAS算法拙见/">CAS算法拙见</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：ThreadLocal/">Java并发编程：ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之Lock与Condition/">生产者消费者模型之Lock与Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/生产者消费者模型之synchronized与Object/">生产者消费者模型之synchronized与Object</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK发令枪CountDownLatch/">JDK发令枪CountDownLatch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/JDK自带线程池/">JDK自带线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java并发编程：Lock/">Java并发编程：Lock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/几种锁的概念/">几种锁的概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/记一次AOP-反射-自定义注解结合的应用/">记一次AOP,反射,自定义注解结合的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/1秒30000QPS-前后端设计思路/">1秒30000QPS,前后端设计思路</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="广告位1" target="_blank">广告位1</a><ul></ul><a href="http://www.example2.com/" title="广告位2" target="_blank">广告位2</a><ul></ul><a href="http://www.example3.com/" title="广告位3" target="_blank">广告位3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">来一杯82年的Java.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>